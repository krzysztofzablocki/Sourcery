//
// Created by Krzysztof Zablocki on 11/09/2016.
// Copyright (c) 2016 Pixle. All rights reserved.
//

import Foundation
import SourceKittenFramework
import PathKit

private extension Variable {
    /// Source structure used by the parser
    var __underlyingSource: [String: SourceKitRepresentable] {
        return (__parserData as? [String: SourceKitRepresentable]) ?? [:]
    }
}

private extension Type {
    /// Source structure used by the parser
    var __underlyingSource: [String: SourceKitRepresentable] {
        return (__parserData as? [String: SourceKitRepresentable]) ?? [:]
    }

    /// sets underlying source
    func setSource(source: [String: SourceKitRepresentable]) {
        __parserData = source
    }
}

fileprivate enum SubstringIdentifier {
    case body
    case key
    case name
    case nameSuffix
    case keyPrefix

    func range(`for` source: [String: SourceKitRepresentable]) -> (offset: Int64, length: Int64)? {

        func extract(_ offset: SwiftDocKey, _ length: SwiftDocKey) -> (offset: Int64, length: Int64)? {
            if let offset = source[offset.rawValue] as? Int64, let length = source[length.rawValue] as? Int64 {
                return (offset, length)
            }
            return nil
        }

        switch self {
        case .body:
            return extract(.bodyOffset, .bodyLength)
        case .key:
            return extract(.offset, .length)
        case .name:
            return extract(.nameOffset, .nameLength)
        case .nameSuffix:
            if let name = SubstringIdentifier.name.range(for: source), let key = SubstringIdentifier.key.range(for: source) {
                let nameEnd = name.offset + name.length
                return (name.offset + name.length, key.offset + key.length - nameEnd)
            }
        case .keyPrefix:
            return SubstringIdentifier.key.range(for: source).flatMap { (offset: 0, length: $0.offset) }
        }

        return nil
    }
}

typealias ParserResult = (types: [Type], typealiases: [String: String])

final class Parser {

    let verbose: Bool
    fileprivate var contents: String = ""
    fileprivate var path: String? = nil
    fileprivate var logPrefix: String {
        return path.flatMap { "\($0): " } ?? ""
    }

    init(verbose: Bool = false) {
        self.verbose = verbose
    }

    /// Parses file under given path.
    ///
    /// - Parameters:
    ///   - path: Path to file.
    ///   - existingTypes: List of existing types to use for further parsing.
    /// - Returns: All types we could find.
    /// - Throws: parsing errors.
    public func parseFile(_ path: Path, existingTypes: ParserResult = ([], [:])) throws -> ParserResult {
        self.path = path.string
        return parseContents(try path.read(.utf8), existingTypes: existingTypes)
    }

    /// Parses given file context.
    ///
    /// - Parameters:
    ///   - contents: Contents of the file.
    ///   - existingTypes: List of existing types to use for further parsing.
    /// - Returns: All types we could find.
    /// - Throws: parsing errors.
    public func parseContents(_ contents: String, existingTypes: ParserResult = ([], [:])) -> ParserResult {
        guard !contents.hasPrefix(Sourcery.generationMarker) else {
            if verbose { print("\(logPrefix)Skipping source file because it was generated by Sourcery") }
            return existingTypes
        }

        self.contents = contents
        
        let file = File(contents: contents)
        let types = parseTypes(Structure(file: file).dictionary, existingTypes: existingTypes.types)
        let typealiases = parseTypeAliases(SyntaxMap(file: file).tokens, existingTypealiases: existingTypes.typealiases)
        return (types, typealiases)
    }
    
    internal func parseTypeAliases(_ tokens: [SyntaxToken], existingTypealiases: [String: String]) -> [String: String] {
        var typealiases = existingTypealiases
        tokens.enumerated()
            .filter { _, token in
                guard token.type == "source.lang.swift.syntaxtype.keyword" else { return false }
                guard let keyword = contents.bridge().substringWithByteRange(start: token.offset, length: token.length) else { return false }
                return keyword == "typealias"
            }
            .map({ (index, _) in (tokens[index + 1], tokens[index + 2]) })
            .forEach({ (aliasToken, typeToken) in
                guard
                    let alias = contents.bridge().substringWithByteRange(start: aliasToken.offset, length: aliasToken.length),
                    let type = contents.bridge().substringWithByteRange(start: typeToken.offset, length: typeToken.length) else { return }
                
                typealiases[alias] = type
            })
        return typealiases
    }

    internal func parseTypes(_ source: [String: SourceKitRepresentable], existingTypes: [Type] = []) -> [Type] {
        var types = existingTypes
        walkTypes(source: source) { kind, name, access, inheritedTypes, source in
            let type: Type

            switch kind {
            case .protocol:
                type = Protocol(name: name, accessLevel: access, isExtension: false, inheritedTypes: inheritedTypes)
            case .class:
                type = Type(name: name, accessLevel: access, isExtension: false, inheritedTypes: inheritedTypes)
            case .extension:
                type = Type(name: name, accessLevel: access, isExtension: true, inheritedTypes: inheritedTypes)
            case .extensionClass:
                type = Type(name: name, accessLevel: access, isExtension: true, inheritedTypes: inheritedTypes)
            case .struct:
                type = Struct(name: name, accessLevel: access, isExtension: false, inheritedTypes: inheritedTypes)
            case .extensionStruct:
                type = Struct(name: name, accessLevel: access, isExtension: true, inheritedTypes: inheritedTypes)
            case .enum:
                type = Enum(name: name, accessLevel: access, isExtension: false, inheritedTypes: inheritedTypes)
            case .extensionEnum:
                type = Enum(name: name, accessLevel: access, isExtension: true, inheritedTypes: inheritedTypes)
            case .enumelement:
                return parseEnumCase(source)
            case .varInstance:
                return parseVariable(source)
            case .varStatic:
                return parseVariable(source, isStatic: true)
            case .varLocal, .varParameter:
                //! Don't log local / param vars
                return nil
            default:
                //! Don't log functions
                if kind.rawValue.hasPrefix("source.lang.swift.decl.function") { return nil }

                if verbose { print("\(logPrefix)Unsupported entry \"\(access) \(kind) \(name)\"") }
                return nil
            }

            type.setSource(source: source)
            type.annotations = parseAnnotations(source)

            types.append(type)
            return type
        }

        return types
    }

    private func walkTypes(source: [String: SourceKitRepresentable], containingType: Any? = nil, foundEntry: (SwiftDeclarationKind, String, AccessLevel, [String], [String: SourceKitRepresentable]) -> Any?) {
        var type = containingType

        let inheritedTypes = extractInheritedTypes(source: source)

        if let requirements = parseTypeRequirements(source) {
            type = foundEntry(requirements.kind, requirements.name, requirements.accessibility, inheritedTypes, source)
            if let type = type, let containingType = containingType {
                processContainedType(type, within: containingType)
            }
        }

        if let substructures = source[SwiftDocKey.substructure.rawValue] as? [SourceKitRepresentable] {
            for substructure in substructures {
                if let substructure = substructure as? [String: SourceKitRepresentable] {
                    walkTypes(source: substructure, containingType: type, foundEntry: foundEntry)
                }
            }
        }
    }

    private func processContainedType(_ type: Any, within containingType: Any) {
        ///! only Type can contain children
        guard let containingType = containingType as? Type else {
            return
        }

        switch (containingType, type) {
        case let (_, variable as Variable):
            if variable.isStatic {
                containingType.staticVariables += [variable]
            } else {
                containingType.variables += [variable]

                if let enumeration = containingType as? Enum, let updatedRawType = parseEnumRawType(enumeration: enumeration, from: variable) {
                    enumeration.rawType = updatedRawType
                }
            }

        case let (_, childType as Type):
            containingType.containedTypes += [childType]
            childType.parentName = containingType.name
        case let (enumeration as Enum, enumCase as Enum.Case):
            enumeration.cases += [enumCase]
        default:
            break
        }
    }

    /// Extends types with their corresponding extensions.
    ///
    /// - Parameter types: Types and extensions.
    /// - Returns: Just types.
    internal func uniqueTypes(_ ParserResult: ParserResult) -> [Type] {
        var unique = [String: Type]()
        let types = ParserResult.types
        let typealiases = ParserResult.typealiases
        
        //replace extensions for type aliases with original types
        types
            .filter { $0.isExtension == true }
            .forEach { $0.localName = typealiases[$0.name] ?? $0.localName }

        types
            .filter { $0.isExtension == false }
            .forEach { unique[$0.name] = $0 }

        types.forEach { type in
            guard let current = unique[type.name] else {
                let inheritanceClause = type.inheritedTypes.isEmpty ? "" : ": \(type.inheritedTypes)"
                if verbose { print("\(logPrefix)Ignoring \"extension \(type.name)\(inheritanceClause)\" because we don't have original type definition information") }
                return
            }
            if current == type { return }

            current.extend(type)
            unique[type.name] = current
        }
        
        for (_, type) in unique {
            for variable in type.variables {
                if let actualTypeName = typealiases[variable.unwrappedTypeName] {
                    variable.type = unique[actualTypeName]
                } else {
                    variable.type = unique[variable.unwrappedTypeName]
                }
            }
        }

        return unique.values.sorted { $0.name < $1.name }
    }
    
}

// MARK: Details parsing
extension Parser {

    fileprivate func parseTypeRequirements(_ dict: [String: SourceKitRepresentable]) -> (name: String, kind: SwiftDeclarationKind, accessibility: AccessLevel)? {
        guard let kind = (dict[SwiftDocKey.kind.rawValue] as? String).flatMap({ SwiftDeclarationKind(rawValue: $0) }),
              let name = dict[SwiftDocKey.name.rawValue] as? String else { return nil }

        let accessibility = (dict["key.accessibility"] as? String).flatMap({ AccessLevel(rawValue: $0.replacingOccurrences(of: "source.lang.swift.accessibility.", with: "") ) }) ?? .none
        return (name, kind, accessibility)
    }

    internal func extractInheritedTypes(source: [String: SourceKitRepresentable]) -> [String] {
        return (source[SwiftDocKey.inheritedtypes.rawValue] as? [[String: SourceKitRepresentable]])?.flatMap { type in
            return type[SwiftDocKey.name.rawValue] as? String
        } ?? []
    }

    internal func parseVariable(_ source: [String: SourceKitRepresentable], isStatic: Bool = false) -> Variable? {
        guard let (name, _, accesibility) = parseTypeRequirements(source),
            let type = source[SwiftDocKey.typeName.rawValue] as? String else { return nil }

        var writeAccessibility = AccessLevel.none
        var computed = false

        //! if there is body it might be computed
        if let bodylength = source[SwiftDocKey.bodyLength.rawValue] as? Int64 {
            computed = bodylength > 0
        }

        //! but if there is a setter, then it's not computed for sure
        if let setter = source["key.setter_accessibility"] as? String {
            writeAccessibility = AccessLevel(rawValue: setter.replacingOccurrences(of: "source.lang.swift.accessibility.", with: "")) ?? .none
            computed = false
        }

        let variable = Variable(name: name, type: type, accessLevel: (read: accesibility, write: writeAccessibility), isComputed: computed, isStatic: isStatic)
        variable.annotations = parseAnnotations(source)
        variable.__parserData = source

        return variable
    }

    fileprivate func parseEnumCase(_ source: [String: SourceKitRepresentable]) -> Enum.Case? {
        guard let (name, _, _) = parseTypeRequirements(source) else { return nil }

        var associatedValues: [Enum.Case.AssociatedValue] = []
        var rawValue: String? = nil

        if let wrappedBody = extract(.nameSuffix, from: source)?.trimmingCharacters(in: .whitespacesAndNewlines) {
            switch (wrappedBody.characters.first, wrappedBody.characters.last) {
            case ("="?, _):
                let body = wrappedBody.substring(from: wrappedBody.index(after: wrappedBody.startIndex)).trimmingCharacters(in: .whitespacesAndNewlines)
                rawValue = parseEnumValues(body)
            case ("("?, ")"?):
                let body = wrappedBody.substring(with: wrappedBody.index(after: wrappedBody.startIndex)..<wrappedBody.index(before: wrappedBody.endIndex)).trimmingCharacters(in: .whitespacesAndNewlines)
                associatedValues = parseEnumAssociatedValues(body)
            default:
                print("\(logPrefix)parseEnumCase: Unknown enum case body format \(wrappedBody)")
            }
        }

        return Enum.Case(name: name, rawValue: rawValue, associatedValues: associatedValues)
    }

    fileprivate func parseEnumValues(_ body: String) -> String {
        /// = value
        let body = body.replacingOccurrences(of: "\"", with: "")
        return body.trimmingCharacters(in: .whitespacesAndNewlines)
    }

    fileprivate func parseEnumAssociatedValues(_ body: String) -> [Enum.Case.AssociatedValue] {
        guard !body.isEmpty else { return [] }

        /// name: type, otherType
        let components = body.components(separatedBy: ",")
        return components.flatMap { element in
            let nameType = element.components(separatedBy: ":").map { $0.trimmingCharacters(in: .whitespacesAndNewlines) }

            switch nameType.count {
            case 1:
                return Enum.Case.AssociatedValue(name: nil, type: nameType.first ?? "")
            case 2:
                return Enum.Case.AssociatedValue(name: nameType.first, type: nameType.last ?? "")
            default:
                print("\(logPrefix)parseEnumAssociatedValues: Unknown enum case body format \(body)")
                return nil
            }
        }
    }

    fileprivate func parseEnumRawType(enumeration: Enum, from variable: Variable) -> String? {
        guard variable.name == "rawValue" else {
            return nil
        }

        if variable.typeName == "RawValue" {
            return parseEnumRawValueAssociatedType(enumeration.__underlyingSource)
        }

        return variable.typeName
    }

    fileprivate func parseEnumRawValueAssociatedType(_ source: [String: SourceKitRepresentable]) -> String? {
        var rawType: String?

        extract(.body, from: source)?
            .replacingOccurrences(of: ";", with: "\n")
            .enumerateLines(invoking: { (substring, stop) in
                let substring = substring.trimmingCharacters(in: .whitespacesAndNewlines)

                if substring.hasPrefix("typealias"), let type = substring.components(separatedBy: " ").last {
                    rawType = type
                    stop = true
                }
            })

        return rawType
    }

    fileprivate func parseAnnotations(_ source: [String: SourceKitRepresentable]) -> [String: NSObject] {
        guard let substring = extract(.keyPrefix, from: source) else { return [:] }

        var annotations = [String: NSObject]()

        let newlines = NSCharacterSet.newlines
        let lines = substring
                .unicodeScalars
                .split(omittingEmptySubsequences: false, whereSeparator: { newlines.contains($0) })
                .flatMap(String.init)
                .reversed()
                .dropFirst()    //! last line is the actual key definition so skip it

        var commentLines = [String]()

        //! move lines iteratively and stop after the first one that's not a comment line:
        for var line in lines {
            line = line.trimmingCharacters(in: .whitespaces)
            if !line.hasPrefix("//") {
                break
            }

            commentLines.append(line)
        }

        let annotationDefinitions = commentLines
                .filter { $0.contains("sourcery:") }
                .flatMap { line in line.range(of: "sourcery:").flatMap { line.substring(from: $0.upperBound).trimmingCharacters(in: .whitespaces) } }
                .flatMap { $0.components(separatedBy: ",").map { $0.trimmingCharacters(in: .whitespaces) } }

        annotationDefinitions.forEach { annotation in
            let parts = annotation.components(separatedBy: "=").map { $0.trimmingCharacters(in: .whitespaces) }
            if let name = parts.first, !name.isEmpty {

                guard parts.count > 1, var value = parts.last, value.isEmpty == false else {
                    annotations[name] = NSNumber(value: true)
                    return
                }

                if let number = Float(value) {
                    annotations[name] = NSNumber(value: number)
                } else {
                    if (value.hasPrefix("'") && value.hasSuffix("'")) || (value.hasPrefix("\"") && value.hasSuffix("\"")) {
                        value = value[value.characters.index(after: value.startIndex) ..< value.characters.index(before: value.endIndex)]
                    }
                    annotations[name] = value as NSString
                }
            }
        }

        return annotations
    }

    fileprivate func extract(_ substringIdentifier: SubstringIdentifier, from source: [String: SourceKitRepresentable]) -> String? {
        let substring = substringIdentifier.range(for: source).flatMap { self.contents.substringWithByteRange(start: Int($0.offset), length: Int($0.length)) }
        return substring?.isEmpty == true ? nil : substring
    }
}
