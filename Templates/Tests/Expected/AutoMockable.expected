import Foundation
#if os(iOS) || os(tvOS) || os(watchOS)
import UIKit
#elseif os(OSX)
import AppKit
#endif


class BasicProtocolMock: BasicProtocol {

    //MARK: - loadConfiguration

    var loadConfiguration_Called = false
    var loadConfiguration_ReturnValue: String?!

    func loadConfiguration() -> String? {
        loadConfiguration_Called = true
        return loadConfiguration_ReturnValue
    }
    //MARK: - save

    var save_configuration_Called = false
    var save_configuration_ReceivedConfiguration: String?

    func save(configuration: String) {
        save_configuration_Called = true
        save_configuration_ReceivedConfiguration = configuration
    }
}
class ExtendableProtocolMock: ExtendableProtocol {
    var canReport: Bool!

    //MARK: - report

    var report_message_Called = false
    var report_message_ReceivedMessage: String?

    func report(message: String) {
        report_message_Called = true
        report_message_ReceivedMessage = message
    }
    //MARK: - extension_report

    var extension_report_message_Called = false
    var extension_report_message_ReceivedMessage: String?

    func report(message: String = "Test") {
        extension_report_message_Called = true
        extension_report_message_ReceivedMessage = message
    }
}
class InitializationProtocolMock: InitializationProtocol {

    //MARK: - init

    var init_intParameter_stringParameter_optionalParameter_ReceivedArguments: (intParameter: Int, stringParameter: String, optionalParameter: String?)?

    required init(intParameter: Int, stringParameter: String, optionalParameter: String?) {
        init_intParameter_stringParameter_optionalParameter_ReceivedArguments = (intParameter: intParameter, stringParameter: stringParameter, optionalParameter: optionalParameter)
    }
    //MARK: - start

    var start_Called = false

    func start() {
        start_Called = true
    }
    //MARK: - stop

    var stop_Called = false

    func stop() {
        stop_Called = true
    }
}
class ReservedWordsProtocolMock: ReservedWordsProtocol {

    //MARK: - `continue`

    var continue_with_Called = false
    var continue_with_ReceivedMessage: String?
    var continue_with_ReturnValue: String!

    func `continue`(with message: String) -> String {
        continue_with_Called = true
        continue_with_ReceivedMessage = message
        return continue_with_ReturnValue
    }

}
class SameShortMethodNamesProtocolMock: SameShortMethodNamesProtocol {

    //MARK: - start

    var start_car_of_Called = false
    var start_car_of_ReceivedArguments: (car: String, model: String)?

    func start(car: String, of model: String) {
        start_car_of_Called = true
        start_car_of_ReceivedArguments = (car: car, model: model)
    }
    //MARK: - start

    var start_plane_of_Called = false
    var start_plane_of_ReceivedArguments: (plane: String, model: String)?

    func start(plane: String, of model: String) {
        start_plane_of_Called = true
        start_plane_of_ReceivedArguments = (plane: plane, model: model)
    }
}
class ThrowableProtocolMock: ThrowableProtocol {

    //MARK: - doOrThrow

    var doOrThrow_ThrowableError: Error?
    var doOrThrow_Called = false
    var doOrThrow_ReturnValue: String!

    func doOrThrow() throws -> String {
        if let error = doOrThrow_ThrowableError {
            throw error
        }
        doOrThrow_Called = true
        return doOrThrow_ReturnValue
    }

}
class VariablesProtocolMock: VariablesProtocol {
    var company: String?
    var name: String!
    var age: Int!
    var kids: [String] = []
    var universityMarks: [String: Int] = [:]

}
