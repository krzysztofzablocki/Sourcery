<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Writing templates  Reference</title>
    <link rel="stylesheet" type="text/css" href="css/jazzy.css" />
    <link rel="stylesheet" type="text/css" href="css/highlight.css" />
    <meta charset='utf-8'>
    <script src="js/jquery.min.js" defer></script>
    <script src="js/jazzy.js" defer></script>
    
  </head>
  <body>
    <a title="Writing templates  Reference"></a>
    <header>
      <div class="content-wrapper">
        <p><a href="index.html">Sourcery Docs</a> (100% documented)</p>
        <p class="header-right"><a href="https://github.com/krzysztofzablocki/Sourcery"><img src="img/gh.png"/>View on GitHub</a></p>
      </div>
    </header>
    <div class="content-wrapper">
      <p id="breadcrumbs">
        <a href="index.html">Sourcery Reference</a>
        <img id="carat" src="img/carat.png" />
        Writing templates  Reference
      </p>
    </div>
    <div class="content-wrapper">
      <nav class="sidebar">
        <ul class="nav-groups">
          <li class="nav-group-name">
            <a href="Guides.html">Guides</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="installing.html">Installing</a>
              </li>
              <li class="nav-group-task">
                <a href="usage.html">Usage</a>
              </li>
              <li class="nav-group-task">
                <a href="writing-templates.html">Writing templates</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a href="Examples.html">Examples</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="equatable.html">Equatable</a>
              </li>
              <li class="nav-group-task">
                <a href="hashable.html">Hashable</a>
              </li>
              <li class="nav-group-task">
                <a href="enum-cases.html">Enum cases</a>
              </li>
              <li class="nav-group-task">
                <a href="lenses.html">Lenses</a>
              </li>
              <li class="nav-group-task">
                <a href="mocks.html">Mocks</a>
              </li>
              <li class="nav-group-task">
                <a href="codable.html">Codable</a>
              </li>
              <li class="nav-group-task">
                <a href="diffable.html">Diffable</a>
              </li>
              <li class="nav-group-task">
                <a href="linuxmain.html">LinuxMain</a>
              </li>
              <li class="nav-group-task">
                <a href="decorator.html">Decorator</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a href="Types.html">Types</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Classes/Types.html">Types</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/Type.html">Type</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/Protocol.html">Protocol</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/Class.html">Class</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/Struct.html">Struct</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/Enum.html">Enum</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/EnumCase.html">EnumCase</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/AssociatedValue.html">AssociatedValue</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/Variable.html">Variable</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/Method.html">Method</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/MethodParameter.html">MethodParameter</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/Subscript.html">Subscript</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/TypeName.html">TypeName</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/TupleType.html">TupleType</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/TupleElement.html">TupleElement</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/ArrayType.html">ArrayType</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/DictionaryType.html">DictionaryType</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/ClosureType.html">ClosureType</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/GenericType.html">GenericType</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/GenericTypeParameter.html">GenericTypeParameter</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/Attribute.html">Attribute</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a href="Other Protocols.html">Other Protocols</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Protocols/Annotated.html">Annotated</a>
              </li>
              <li class="nav-group-task">
                <a href="Protocols/Definition.html">Definition</a>
              </li>
              <li class="nav-group-task">
                <a href="Protocols/Typed.html">Typed</a>
              </li>
            </ul>
          </li>
        </ul>
      </nav>
      <article class="main-content">
        <section>
          <section class="section">
            
            <h2 id='writing-templates' class='heading'>Writing templates</h2>

<p>Sourcery supports templates written in Stencil, Swift and even JavaScript.</p>

<p>Discovered types can be accessed in templates via global context with following properties:</p>

<ul>
<li><code>types: Types</code> - access collections of types, i.e. <code>types.implementing.AutoCoding</code> (<code>types.implementing[&quot;AutoCoding&quot;]</code> in swift templates). See <a href="https://cdn.rawgit.com/krzysztofzablocki/Sourcery/master/docs/Classes/Types.html">Types</a>.</li>
<li><code>type: [String: Type]</code> - access types by their names, i.e. <code>type.MyType</code> (<code>type[&quot;MyType&quot;]</code> in swift templates)</li>
<li><code>arguments: [String: NSObject]</code> - access additional parameters passed with <code>--args</code> command line flag or set in <code>.sourcery.yml</code> file</li>
</ul>

<blockquote>
<p>Tip: Make sure you leverage Sourcery built-in daemon to make writing templates a pleasure:
you can open template side-by-side with generated code and see it change live.</p>
</blockquote>
<h2 id='what-are-em-known-em-and-em-unknown-em-types' class='heading'>What are <em>known</em> and <em>unknown</em> types</h2>

<p>Currently Sourcery only scans files from paths or targets that you tell it to scan. This way it can get full information about types <em>defined</em> in these sources. These types are considered <em>known</em> types. For each of known types Sourcery provides <code>Type</code> object. You can get it for example by its name from <code>types</code> collection. <code>Type</code> object contains information about whether type that it describes is a struct, enum, class or a protocol, what are its properties and methods, what protocols it implements and so on. This is done recursively, so if you have a class that inherits from another class (or struct that implements a protocol) and they are both known types you will have information about both of them and you will be able to access parent type&rsquo;s <code>Type</code> object using <code>type.inherits.TypeName</code> (or <code>type.implements.ProtocolName</code>).</p>

<p>Everything <em>defined</em> outside of scanned sources is considered as <em>unknown</em> types. For such types Sourcery doesn&rsquo;t provide <code>Type</code> object. For that reason variables (and other <q>typed</q> types, like method parameters etc.) of such types will only contain <code>typeName</code> property, but their <code>type</code> property will be <code>nil</code>.</p>

<p>If you have an extension of unknown type defined in scanned sources Sourcery will create <code>Type</code> for it (it&rsquo;s <code>kind</code> property will be <code>extension</code>). But this object will contain only declarations defined in this extension. Several extensions of unknown type will be merged into one <code>Type</code> object the same way as extensions of known types.</p>

<p>See <a href="https://github.com/krzysztofzablocki/Sourcery/issues/87">#87</a> for details.</p>
<h2 id='stencil-templates' class='heading'>Stencil templates</h2>

<p><a href="http://stencil.fuller.li/en/latest/">Stencil</a> is a simple and powerful template language for Swift. It provides a syntax similar to Django and Mustache.
Sourcery also uses its extension <a href="https://github.com/SwiftGen/StencilSwiftKit">StencilSwiftKit</a> so you have access to additional nodes and filteres defined there.</p>

<p><strong>Example</strong>: <a href="https://github.com/krzysztofzablocki/Sourcery/blob/master/Sourcery/Templates/Equality.stencil">Equality.stencil</a></p>
<h3 id='custom-stencil-tags-and-filters' class='heading'>Custom Stencil tags and filters</h3>

<ul>
<li><code>{{ name|upperFirstLetter }}</code> - makes first letter in <code>name</code> uppercase</li>
<li><code>{{ name|lowerFirstLetter }}</code> - makes first letter in <code>name</code> lowercase</li>
<li><code>{{ name|replace:&quot;substring&quot;,&quot;replacement&quot; }}</code> - replaces occurances of <code>substring</code> with <code>replacement</code> in <code>name</code> (case sensitive)</li>
<li><code>{% if name|contains:&quot;Foo&quot; %}</code> - check if <code>name</code> contains arbitrary substring, can be negated with <code>!</code> prefix.</li>
<li><code>{% if name|hasPrefix:&quot;Foo&quot; %}</code>- check if <code>name</code> starts with arbitrary substring, can be negated with <code>!</code> prefix.</li>
<li><code>{% if name|hasSuffix:&quot;Foo&quot; %}</code>- check if <code>name</code> ends with arbitrary substring, can be negated with <code>!</code> prefix.</li>
<li><code>static</code>, <code>instance</code>, <code>computed</code>, <code>stored</code>, <code>tuple</code> - can be used on Variable[s] as filter e.g. <code>{% for var in variables|instance %}</code>, can be negated with <code>!</code> prefix.</li>
<li><code>static</code>, <code>instance</code>, <code>class</code>, <code>initializer</code> - can be used on Method[s] as filter e.g. <code>{% for method in allMethods|instance %}</code>, can be negated with <code>!</code> prefix.</li>
<li><code>enum</code>, <code>class</code>, <code>struct</code>, <code>protocol</code> - can be used for Type[s] as filter, can be negated with <code>!</code> prefix.</li>
<li><code>based</code>, <code>implements</code>, <code>inherits</code> - can be used for Type[s], Variable[s], Associated value[s], can be negated with <code>!</code> prefix.</li>
<li><code>count</code> - can be used to get count of filtered array</li>
<li><code>annotated</code> - can be used on Type[s], Variable[s], Method[s] and Enum Case[s] to filter by annotation, e.g. <code>{% for var in variable|annotated:&quot;skipDescription&quot; %}</code>, can be negated with <code>!</code> prefix.</li>
<li><code>public</code>, <code>open</code>, <code>internal</code>, <code>private</code>, <code>fileprivate</code> - can be used on Type[s] and Method[s] to filter by access level, can be negated with <code>!</code> prefix.</li>
<li><code>publicGet</code>, <code>publicSet</code>, .etc - can be used on Variable[s] to filter by getter or setter access level, can be nagated with <code>!</code> prefix</li>
</ul>

<p>You can also use partial templates using <code>include</code> tag. Partial template is loaded from the path of a template that inculdes it. <code>include</code> tags also supports loading templates from relative path, i.e. <code>{% include &quot;partials/MyPartial.stencil&quot;%}</code> used in the template located in <code>templates</code> directory will load template from <code>templates/partials</code> directory.</p>

<blockquote>
<p>Note: You can only load partial templates from child directories of the including template directory, so <code>{% include &quot;../MyPartial.stencil&quot;%}</code> is not supported.</p>
</blockquote>

<p>Sourcery treat all the templates as independent and so will generate files based on partial templates too. To avoid that use <code>exclude</code> in <a href="usage.html#configuration-file">configuration file</a>.</p>
<h2 id='swift-templates' class='heading'>Swift templates</h2>

<p>Swift templates syntax is very similar to EJS:</p>

<ul>
<li>Control flow with <code>&lt;% %&gt;</code></li>
<li>Output value with <code>&lt;%= %&gt;</code></li>
<li>Trim extra new line after control flow tag with <code>-%&gt;</code></li>
<li>Trim <em>all</em> whitespaces before/after control flow tag with <code>&lt;%_</code> and <code>_%&gt;</code></li>
<li>Use <code>&lt;%# %&gt;</code> for comments</li>
<li>Use <code>&lt;%- include(&quot;relative_path_to_template.swifttemplate&quot;) %&gt;</code> to include another template. The <code>swifttemplate</code> extension can be omitted. The path is relative to the including template.</li>
</ul>

<p><strong>Example</strong>: <a href="https://github.com/krzysztofzablocki/Sourcery/blob/master/SourceryTests/Stub/SwiftTemplates/Equality.swifttemplate">Equality.swifttemplate</a></p>

<p>Template:</p>
<pre class="highlight swift"><code><span class="o">&lt;%</span> <span class="k">for</span> <span class="n">type</span> <span class="k">in</span> <span class="n">types</span><span class="o">.</span><span class="n">all</span> <span class="p">{</span> <span class="o">-%&gt;</span>
  <span class="o">&lt;%</span><span class="n">_</span> <span class="o">%&gt;&lt;%=</span> <span class="n">type</span><span class="o">.</span><span class="n">name</span> <span class="o">%&gt;</span>
<span class="o">&lt;%</span> <span class="p">}</span> <span class="o">%&gt;</span>
</code></pre>

<p>Output:</p>
<pre class="highlight swift"><code><span class="kt">Foo</span>
<span class="kt">Bar</span>
</code></pre>
<h2 id='javascript-templates' class='heading'>JavaScript templates</h2>

<p>JavaScript templates are powered by <a href="http://ejs.co">EJS</a> and support all the features available in this template engine.</p>

<p><strong>Example</strong>: <a href="https://github.com/krzysztofzablocki/Sourcery/blob/master/Sourcery/Templates/JSExport.ejs">JSExport.ejs</a></p>

<blockquote>
<p>Note: when using JavaScript templates with Sourcery built using Swift Package Manager you must provide path to EJS source code using <code>--ejsPath</code> command line argument. Download EJS source code <a href="https://github.com/krzysztofzablocki/Sourcery/blob/master/SourceryJS/Sources/ejs.js">here</a>, put it in some path and pass it when running Sourcery. Otherwise JavaScript templates will be ignored (you will see a warning in the console output).</p>
</blockquote>

<p>You can also use <code>SourceryJS</code> framework independently of Sourcery. You can add it as a Carthge or SPM dependency.</p>
<h2 id='using-source-annotations' class='heading'>Using Source Annotations</h2>

<p>Sourcery supports annotating your classes and variables with special annotations, similar to how attributes work in Rust / Java</p>
<pre class="highlight swift"><code><span class="c1">// sourcery: skipPersistence</span>
<span class="c1">// sourcery: anotherAnnotation = 232, yetAnotherAnnotation = "value"</span>
<span class="c1">/// Some documentation comment</span>
<span class="k">var</span> <span class="nv">precomputedHash</span><span class="p">:</span> <span class="kt">Int</span>
</code></pre>

<p>If you want to attribute multiple items with same attributes, you can use section annotations <code>sourcery:begin</code> and <code>sourcery:end</code>:</p>
<pre class="highlight swift"><code><span class="c1">// sourcery:begin: skipEquality, skipPersistence</span>
  <span class="k">var</span> <span class="nv">firstVariable</span><span class="p">:</span> <span class="kt">Int</span>
  <span class="k">var</span> <span class="nv">secondVariable</span><span class="p">:</span> <span class="kt">Int</span>
<span class="c1">// sourcery:end</span>
</code></pre>

<p>To attribute any declaration in the file use <code>sourcery:file</code> at the top of the file:</p>
<pre class="highlight swift"><code><span class="c1">// sourcery:file: skipEquality</span>
  <span class="k">var</span> <span class="nv">firstVariable</span><span class="p">:</span> <span class="kt">Int</span>
  <span class="k">var</span> <span class="nv">secondVariable</span><span class="p">:</span> <span class="kt">Int</span>
</code></pre>

<p>To group annotations of the same domain you can use annotation namespcases:</p>
<pre class="highlight swift"><code><span class="c1">// sourcery:decoding: key="first", default=0</span>
  <span class="k">var</span> <span class="nv">firstVariable</span><span class="p">:</span> <span class="kt">Int</span>
</code></pre>

<p>This will effectively annotate with <code>decoding.key</code> and <code>decoding.default</code> annotations</p>
<h4 id='rules' class='heading'>Rules:</h4>

<ul>
<li>Multiple annotations can occur on the same line, separated with <code>,</code></li>
<li>You can add multiline annotations</li>
<li>Multiple annotations values with the same key are merged into array</li>
<li>You can interleave annotations with documentation</li>
<li>Sourcery scans all <code>sourcery:</code> annotations in the given comment block above the source until first non-comment/doc line</li>
<li>Using <code>/*</code> and <code>*/</code> for annotation comment you can put it on the same line with your code. This is usefull for annotating methods parameters and enum case associated values. All such annotations should be placed in one comment block. Do not mix inline and regular annotations for the same declaration (usin inline and block annotations is fine)!</li>
</ul>
<h4 id='format' class='heading'>Format:</h4>

<ul>
<li>simple entry, e.g. <code>sourcery: skipPersistence</code></li>
<li>key = number, e.g. <code>sourcery: another = 123</code></li>
<li>key = string, e.g. <code>sourcery: jsonKey = &quot;json_key&quot;</code></li>
</ul>
<h4 id='accessing-in-templates' class='heading'>Accessing in templates:</h4>
<pre class="highlight swift"><code><span class="p">{</span><span class="o">%</span> <span class="k">if</span> <span class="n">variable</span><span class="o">|!</span><span class="nv">annotated</span><span class="p">:</span><span class="s">"skipPersistence"</span> <span class="o">%</span><span class="p">}</span>
  <span class="k">var</span> <span class="nv">local</span><span class="p">{{</span> <span class="n">variable</span><span class="o">.</span><span class="n">name</span><span class="o">|</span><span class="n">capitalize</span> <span class="p">}}</span> <span class="o">=</span> <span class="n">json</span><span class="p">[</span><span class="s">"{{ variable.annotations.jsonKey }}"</span><span class="p">]</span> <span class="k">as?</span> <span class="p">{{</span> <span class="n">variable</span><span class="o">.</span><span class="n">typeName</span> <span class="p">}}</span>
<span class="p">{</span><span class="o">%</span> <span class="n">endif</span> <span class="o">%</span><span class="p">}</span>
</code></pre>
<h4 id='checking-for-existance-of-at-least-one-annotation' class='heading'>Checking for existance of at least one annotation:</h4>

<p>Sometimes it is desirable to only generate code if there&rsquo;s at least one field annotated.</p>
<pre class="highlight swift"><code><span class="p">{</span><span class="o">%</span> <span class="k">if</span> <span class="n">type</span><span class="o">.</span><span class="n">variables</span><span class="o">|</span><span class="nv">annotated</span><span class="p">:</span><span class="s">"jsonKey"</span> <span class="o">%</span><span class="p">}{</span><span class="o">%</span> <span class="k">for</span> <span class="k">var</span> <span class="nv">in</span> <span class="n">type</span><span class="o">.</span><span class="n">variables</span><span class="o">|</span><span class="n">instance</span><span class="o">|</span><span class="nv">annotated</span><span class="p">:</span><span class="s">"jsonKey"</span> <span class="o">%</span><span class="p">}</span>
  <span class="k">var</span> <span class="nv">local</span><span class="p">{{</span> <span class="kd">var</span><span class="o">.</span><span class="n">name</span><span class="o">|</span><span class="n">capitalize</span> <span class="p">}}</span> <span class="o">=</span> <span class="n">json</span><span class="p">[</span><span class="s">"{{ var.annotations.jsonKey }}"</span><span class="p">]</span> <span class="k">as?</span> <span class="p">{{</span> <span class="kd">var</span><span class="o">.</span><span class="n">typeName</span> <span class="p">}}</span>
<span class="p">{</span><span class="o">%</span> <span class="n">endfor</span> <span class="o">%</span><span class="p">}{</span><span class="o">%</span> <span class="n">endif</span> <span class="o">%</span><span class="p">}</span>
</code></pre>
<h2 id='inline-code-generation' class='heading'>Inline code generation</h2>

<p>Sourcery supports inline code generation, you just need to put same markup in your code and template, e.g.</p>
<pre class="highlight swift"><code><span class="c1">// in template:</span>

<span class="p">{</span><span class="o">%</span> <span class="k">for</span> <span class="n">type</span> <span class="k">in</span> <span class="n">types</span><span class="o">.</span><span class="n">all</span> <span class="o">%</span><span class="p">}</span>
<span class="c1">// sourcery:inline:{{ type.name }}.TemplateName</span>
<span class="c1">// sourcery:end</span>
<span class="p">{</span><span class="o">%</span> <span class="n">endfor</span> <span class="o">%</span><span class="p">}</span>

<span class="c1">// in source code:</span>

<span class="kd">class</span> <span class="kt">MyType</span> <span class="p">{</span>

<span class="c1">// sourcery:inline:MyType.TemplateName</span>
<span class="c1">// sourcery:end</span>

<span class="p">}</span>
</code></pre>

<p>Sourcery will generate the template code and then perform replacement in your source file by matching annotation comments. Inlined generated code is not parsed to avoid chicken-egg problem.</p>
<h4 id='automatic-inline-code-generation' class='heading'>Automatic inline code generation</h4>

<p>To avoid having to place the markup in your source files, you can use <code>inline:auto:{{ type.name }}.TemplateName</code>:</p>
<pre class="highlight swift"><code><span class="c1">// in template:</span>

<span class="p">{</span><span class="o">%</span> <span class="k">for</span> <span class="n">type</span> <span class="k">in</span> <span class="n">types</span><span class="o">.</span><span class="n">all</span> <span class="o">%</span><span class="p">}</span>
<span class="c1">// sourcery:inline:auto:{{ type.name }}.TemplateName</span>
<span class="c1">// sourcery:end</span>
<span class="p">{</span><span class="o">%</span> <span class="n">endfor</span> <span class="o">%</span><span class="p">}</span>

<span class="c1">// in source code:</span>

<span class="kd">class</span> <span class="kt">MyType</span> <span class="p">{}</span>

<span class="c1">// after running Sourcery:</span>

<span class="kd">class</span> <span class="kt">MyType</span> <span class="p">{</span>
<span class="c1">// sourcery:inline:auto:MyType.TemplateName</span>
<span class="c1">// sourcery:end</span>
<span class="p">}</span>
</code></pre>

<p>The needed markup will be automatically added at the end of the type declaration body. After first parse Sourcery will work with generated code annotated with <code>inline:auto</code> the same way as annotated with <code>inline</code>, so you can even move these blocks of code anywhere in the same file.</p>
<h2 id='per-file-code-generation' class='heading'>Per file code generation</h2>

<p>Sourcery supports generating code in a separate file per type, you just need to put <code>file</code> annotation in a template, e.g.</p>
<pre class="highlight swift"><code><span class="p">{</span><span class="o">%</span> <span class="k">for</span> <span class="n">type</span> <span class="k">in</span> <span class="n">types</span><span class="o">.</span><span class="n">all</span> <span class="o">%</span><span class="p">}</span>
<span class="c1">// sourcery:file:Generated/{{ type.name}}+TemplateName</span>
<span class="c1">// sourcery:end</span>
<span class="p">{</span><span class="o">%</span> <span class="n">endfor</span> <span class="o">%</span><span class="p">}</span>
</code></pre>

<p>Sourcery will generate the template code and then write its annotated parts to corresponding files. In example above it will create <code>Generated/&lt;type name&gt;+TemplateName.generated.swift</code> file for each of scanned types.</p>

<p>If you add an extension to the file name Sourcery will not append <code>generated.swift</code> extension.</p>

          </section>
        </section>
        <section id="footer">
          <p>Copyright © 2016 Pixle. All rights reserved.</p>
          <p>Generated by <a class="link" href="https://github.com/realm/jazzy" target="_blank" rel="external">jazzy ♪♫ v0.8.2</a>, a <a class="link" href="http://realm.io" target="_blank" rel="external">Realm</a> project.</p>
        </section>
      </article>
    </div>
  </body>
</div>
</html>
